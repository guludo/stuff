#!/bin/bash

USAGE='git edit-files <rev...>'

LONG_USAGE='\
Call the editor on the existing files touched by one or more commit (default
to HEAD of no <rev...> is passed).
'

SUBDIRECTORY_OK=1

. "$(git --exec-path)/git-sh-setup"

set -eu -o pipefail

parse_args() {
    if (( $# == 0 )); then
        revs=("HEAD")
    else
        revs=("$@")
    fi
}

collect_files() {
    mapfile -t files < <(
        for rev in "${revs[@]}"; do
            git log -n1 --format= --name-only "$rev"
        done | sort -u
    )
}

get_editor() {
    editor=$(git var GIT_EDITOR)
}

call_editor() {
    if git diff --quiet -- "${files[@]}"; then
        files_had_diff_before=no
    else
        files_had_diff_before=yes
    fi

    if [[ $editor == nvim ]]; then
        "$editor" "${files[@]}" \
                +'vnew' \
                +'read !git show -W' \
                +'set filetype=git buftype=nofile' \
                +'file git-show'
    else
        "$editor" "${files[@]}"
    fi

    if [[ $? -ne 0 ]]; then
        # Editor returned with error; bail out.
        exit $?
    fi

    if git diff --quiet -- "${files[@]}"; then
        files_have_diff_after=no
    else
        files_have_diff_after=yes
    fi
}

menu_prompt() {
    local prompt=$1
    shift  # Rest of arguments are options in the format "<char>: <text>"
    local option
    local option_chars

    for option; do
        option_chars+="${option:0:1}|"
    done

    option_chars="(${option_chars}h:help)"

    REPLY=
    while true; do
        read -rp "$prompt $option_chars "

        if [[ $REPLY == h ]]; then
            for option; do
                echo "$option" >&2
            done
            continue
        fi

        for option; do
            if [[ ${option:0:1} == $REPLY ]]; then
                return
            fi
        done
    done
}

commit() {
    local commit_cmd

    if ! [[ -t 0 ]] || ! [[ -t 1 ]]; then
        return
    fi

    if [[ $files_had_diff_before == yes ]]; then
        echo "info: Files had non-empty diff before the editor. Not trying to amend commit." >&2
        return
    fi

    if [[ $files_have_diff_after != yes ]]; then
        return
    fi

    menu_prompt 'Commit?' \
                'a: amend' \
                's: squash' \
                'f: fixup' \
                'n: do not commit'
    case "$REPLY" in
        a)
            commit_cmd=("git" "commit" "--amend")
            ;;
        s)
            commit_cmd=("git" "commit" "--edit" "--squash=${revs[0]}")
            ;;
        f)
            commit_cmd=("git" "commit" "--edit" "--fixup=${revs[0]}")
            ;;
        n)
            return
            ;;
        *)
            echo "error: unknown option: $REPLY" >&2
            exit 1
            ;;
    esac

    while true; do
        git add -p || true

        if git diff --quiet -- "${files[@]}"; then
            break
        fi

        menu_prompt 'Fiiles still contain unstaged diff. What to do?' \
                    'g: call git add again' \
                    'c: commit anyway' \
                    'q: quit'

        case "$REPLY" in
            g)
                continue
                ;;
            c)
                break
                ;;
            q)
                exit 1
                ;;
            *)
                echo "error: Unknown reply" >&2
                exit 1
                ;;
        esac
    done

    if [[ $editor == nvim ]]; then
        local nvim_commands=(
            '+vnew'
            "'+read !git diff --cached -W'"
            "+'set filetype=git buftype=nofile'"
            "+'file git diff --cached'"
        )
        GIT_EDITOR="$editor ${nvim_commands[*]}" "${commit_cmd[@]}"
    else
        "${commit_cmd[@]}"
    fi
}

cd "$(git rev-parse --show-toplevel)"

parse_args "$@"
collect_files
get_editor
call_editor
commit
